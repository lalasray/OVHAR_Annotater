<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Video + Frame Timeline</title>
  <link rel="stylesheet" href="css/styles.css">
  <!--
    :root {
      --bg: #0b0f14;
      --panel: #121822;
      --panel-2: #1c2533;
      --muted: #9bb0c3;
      --text: #e8f0f8;
      --accent: #5ac8fa;
      --accent-2: #64d2ff;
      --danger: #ff6b6b;
      /* lane colors */
      --lane0:#64d2ff; --lane1:#a0e887; --lane2:#ffd166; --lane3:#ff6b6b;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: linear-gradient(180deg, #0b0f14 0%, #0e141d 100%); color: var(--text); }
    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }
    .title { font-weight: 700; font-size: 22px; letter-spacing: .2px; margin-bottom: 16px; }

    .card { background: var(--panel); border: 1px solid #1a222e; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); overflow: hidden; }
    .row { display: grid; grid-template-columns: 2fr 1fr; gap: 16px; padding: 16px; }
    .col { background: var(--panel-2); border-radius: 12px; padding: 12px; }

    video { width: 100%; max-height: 60vh; background: #000; border-radius: 10px; outline: none; }

    .controls { display: grid; grid-template-columns: repeat(12, 1fr); gap: 8px; align-items: center; margin-top: 10px; }
    .controls > * { min-width: 0; }
    .btn { background: #17202b; color: var(--text); border: 1px solid #233042; border-radius: 10px; padding: 8px 10px; cursor: pointer; }
    .btn:hover { background: #1d2938; }
    .btn-mini { padding: 3px 8px; border-radius: 6px; border: 1px solid #233042; background: #17202b; color: var(--text); cursor: pointer; }
    .input, .number { width: 100%; background: #0f151e; color: var(--text); border: 1px solid #233042; border-radius: 10px; padding: 10px 12px; }
    .number { text-align: right; }
    .label { color: var(--muted); font-size: 12px; margin-top: 12px; margin-bottom: 6px; }

    /* Main timeline */
    .timeline-wrap { position: relative; background: #0c121a; border: 1px solid #223042; border-radius: 12px; overflow: hidden; }
    .timeline { position: relative; height: 140px; overflow: auto; white-space: nowrap; scrollbar-color: #32465f #0c121a; }
    .ticks { position: relative; height: 100%; }
    .tick { position: absolute; top: 0; width: 1px; background: #243448; }
    .tick.major { background: #3e5774; }
    .tick-label { position: absolute; top: 6px; transform: translateX(-50%); font-size: 11px; color: var(--muted); }
    .frame-lane { position: absolute; bottom: 0; height: 60px; left: 0; right: 0; background: linear-gradient(180deg, rgba(100,180,255,0.07), rgba(100,180,255,0.03)); border-top: 1px dashed rgba(90,200,250,0.2); }
    .playhead { position: absolute; top: 0; bottom: 0; width: 0; pointer-events: none; }
    .playhead::before { content: ""; position: absolute; top: 0; left: -8px; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 10px solid var(--accent); }
    .playhead::after { content: ""; position: absolute; top: 10px; left: -1px; width: 2px; bottom: 0; background: var(--accent-2); opacity: .9; }
    .legend { display: flex; gap: 16px; align-items: center; padding: 10px 12px; border-top: 1px solid #203042; color: var(--muted); font-size: 12px; }
    .spacer { flex: 1; }
    .range { width: 100%; }
    .help { font-size: 12px; color: var(--muted); margin-top: 8px; }
    .kbd { background: #0f151e; border: 1px solid #223042; padding: 2px 6px; border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 11px; }

    /* Label lanes */
    #labelTimelines { margin-top: 10px; }
    .label-lane { position: relative; height:35px; background:#0c121a; border:1px solid #223042; border-radius:8px; margin-top:6px; overflow:auto; white-space:nowrap; }
    .label-track { position:absolute; top:0; bottom:0; left:0; background:rgba(255,255,255,0.03); }
    .label-playhead { position:absolute; top:0; bottom:0; width:2px; background:var(--accent-2); pointer-events:none; }
    .label-text { position:absolute; top:2px; left:6px; font-size:11px; color:var(--muted); z-index:2; }

    .range-bar { position:absolute; top:4px; height:27px; border-radius:6px; display:flex; align-items:center; justify-content:center; padding:0 28px 0 8px; font-size:11px; color:#0b0f14; user-select:none; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; z-index:1; }
    .label-lane[data-lane="0"] .range-bar{ background:var(--lane0); }
    .label-lane[data-lane="1"] .range-bar{ background:var(--lane1); }
    .label-lane[data-lane="2"] .range-bar{ background:var(--lane2); }
    .label-lane[data-lane="3"] .range-bar{ background:var(--lane3); }

    /* table styles */
    #rangesWrap{ margin-top:16px; }
    #rangesTable{ width:100%; border-collapse:collapse; font-size:12px; }
    #rangesTable th, #rangesTable td{ border:1px solid #223042; padding:6px 8px; text-align:left; }
    #rangesTable th{ background:#121a25; color:var(--muted); }
  -->
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row">
        <div class="col">
          <div class="video-viewport" id="videoViewport">
            <video id="video" controls crossorigin="anonymous"></video>
          </div>
          <div class="controls">
            <button id="btnPlay" class="btn" style="grid-column: span 2">▶ Play</button>
            <button id="btnPrev" class="btn secondary" title="Prev frame" style="grid-column: span 1">⟨⟨</button>
            <button id="btnNext" class="btn secondary" title="Next frame" style="grid-column: span 1">⟩⟩</button>
            <div style="grid-column: span 3">
              <div class="label">FPS</div>
              <input id="fps" type="number" class="number" min="1" max="240" step="1" value="30" />
            </div>
            <div style="grid-column: span 3">
              <div class="label">Go to Frame</div>
              <input id="gotoFrame" type="number" class="number" min="0" value="0" />
            </div>
            <button id="btnGo" class="btn" style="grid-column: span 2">Go</button>
            <div class="video-zoom-control" style="grid-column: span 12;">
              <span class="zoom-label">Video Zoom</span>
              <input id="videoZoom" class="range" type="range" min="1" max="4" step="0.05" value="1" aria-label="Video zoom" />
              <span id="videoZoomDisplay" class="zoom-value">1.00×</span>
              <button id="videoZoomReset" class="btn-mini" type="button">Reset</button>
            </div>
          </div>
          <div class="help">Shortcuts: <span class="kbd">Space</span> play/pause • <span class="kbd">←/→</span> step by 1 frame • <span class="kbd">Home/End</span> to start/end.</div>
        </div>

        <div class="col">
          <div class="label">Open Video</div>
          <input id="file" type="file" class="input" accept="video/*" />
          <div class="label">or paste a URL</div>
          <input id="url" type="text" class="input" placeholder="https://example.com/video.mp4" />
          <button id="btnLoad" class="btn" style="margin-top:8px">Load</button>

          <div class="label">Info</div>
          <div id="meta" style="font-size:13px;color:var(--muted);"></div>
        </div>
      </div>

      <div class="timeline-wrap">
        <div id="timeline" class="timeline">
          <div class="ticks" id="ticks"></div>
          <div class="frame-lane"></div>
          <div class="playhead" id="playhead"></div>
        </div>
        <div class="legend">
          <div>Frame: <span id="frameOut">0</span></div>
          <div>Time: <span id="timeOut">0.000s</span></div>
          <div class="spacer"></div>
          <div class="legend-zoom">
            <span style="white-space:nowrap">Zoom (frames/line)</span>
            <input id="zoom" class="range" type="range" min="5" max="5000" step="5" value="100" title="Frames visible across the viewport" />
          </div>
        </div>
      </div>
    </div>

    <!-- Label range editor -->
    <div id="labelEditor" style="margin-top:20px; background:var(--panel-2); padding:12px; border-radius:12px;">
      <div class="label">Add Label Range</div>
      <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
        <select id="laneSelect" class="input" style="flex:1; max-width:120px;">
          <option value="0">label 0</option>
          <option value="1">label 1</option>
          <option value="2">label 2</option>
          <option value="3">label 3</option>
        </select>
        <!-- For lanes other than 1 -->
        <div id="singleNameWrap" style="flex:2; min-width:220px;">
          <input id="labelName" type="text" class="input" />
        </div>
        <!-- For lane 1: two separate inputs -->
        <div id="dualNameWrap" style="display:none; flex:2; min-width:300px; gap:8px;">
          <div style="display:flex; flex-direction:column; gap:4px;">
            <div class="label" style="margin:0;">Upper body text</div>
            <input id="upperText" type="text" class="input" />
          </div>
          <div style="display:flex; flex-direction:column; gap:4px;">
            <div class="label" style="margin:0;">Lower body text</div>
            <input id="lowerText" type="text" class="input" />
          </div>
        </div>
        <!-- For lane 2: six inputs (at least one required) -->
        <div id="sixNameWrap" style="display:none; flex:3; min-width:420px; gap:8px; flex-wrap:wrap;">
          <div style="display:flex; flex-direction:column; gap:4px; min-width:200px; flex:1;">
            <div class="label" style="margin:0;">Upper left limb</div>
            <input id="ull" type="text" class="input" />
          </div>
          <div style="display:flex; flex-direction:column; gap:4px; min-width:200px; flex:1;">
            <div class="label" style="margin:0;">Lower left limb</div>
            <input id="lll" type="text" class="input" />
          </div>
          <div style="display:flex; flex-direction:column; gap:4px; min-width:200px; flex:1;">
            <div class="label" style="margin:0;">Upper right limb</div>
            <input id="urlimb" type="text" class="input" />
          </div>
          <div style="display:flex; flex-direction:column; gap:4px; min-width:200px; flex:1;">
            <div class="label" style="margin:0;">Lower right limb</div>
            <input id="lrlimb" type="text" class="input" />
          </div>
          <div style="display:flex; flex-direction:column; gap:4px; min-width:200px; flex:1;">
            <div class="label" style="margin:0;">Torso</div>
            <input id="torso" type="text" class="input" />
          </div>
          <div style="display:flex; flex-direction:column; gap:4px; min-width:200px; flex:1;">
            <div class="label" style="margin:0;">Head</div>
            <input id="head" type="text" class="input" />
          </div>
        </div>
        <input id="startFrame" type="number" class="number" style="flex:1;" />
        <input id="endFrame" type="number" class="number" style="flex:1;" />
        <button id="btnAddLabel" class="btn" style="flex:1; min-width:100px;">Add</button>
      </div>
    </div>

    <!-- Stacked label timelines -->
    <div id="labelTimelines">
      <div class="label-lane" data-lane="0"><div class="label-track"></div><div class="label-playhead"></div><span class="label-text">label 0</span></div>
      <div class="label-lane" data-lane="1"><div class="label-track"></div><div class="label-playhead"></div><span class="label-text">label 1</span></div>
      <div class="label-lane" data-lane="2"><div class="label-track"></div><div class="label-playhead"></div><span class="label-text">label 2</span></div>
      <div class="label-lane" data-lane="3"><div class="label-track"></div><div class="label-playhead"></div><span class="label-text">label 3</span></div>
    </div>

    <!-- Label Ranges table at the very end -->
    <div id="rangesWrap">
      <div class="label">Label Ranges</div>
      <div style="margin:8px 0; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
        <button id="btnExport" class="btn" style="flex:0 0 auto;">Export JSON</button>
        <button id="btnImport" class="btn" style="flex:0 0 auto;">Import JSON</button>
        <input id="importJson" type="file" accept="application/json" style="display:none" />
        <span id="importInfo" style="font-size:12px;color:var(--muted);"></span>
      </div>
      <table id="rangesTable">
        <thead>
          <tr><th>Label ID</th><th>Lane</th><th>Name</th><th>Start</th><th>End (exclusive)</th><th>Actions</th></tr>
        </thead>
        <tbody id="rangesTbody"></tbody>
      </table>
    </div>
  </div>

  <script src="js/app.js"></script>
  <!--
    'use strict';
    // Avoid $ conflicts by using a uniquely named helper.
    const getById = (id) => document.getElementById(id);

    // Element refs
    const video = getById('video');
    const btnPlay = getById('btnPlay');
    const btnPrev = getById('btnPrev');
    const btnNext = getById('btnNext');
    const fpsInput = getById('fps');
    const gotoInput = getById('gotoFrame');
    const btnGo = getById('btnGo');
    const meta = getById('meta');
    const file = getById('file');
    const url = getById('url');
    const btnLoad = getById('btnLoad');

    // Range form elements
    const laneSelect = getById('laneSelect');
    const singleNameWrap = getById('singleNameWrap');
    const dualNameWrap = getById('dualNameWrap');
    const sixNameWrap  = getById('sixNameWrap');
    const labelNameInput = getById('labelName');
    const upperTextInput = getById('upperText');
    const lowerTextInput = getById('lowerText');
    const ullInput = getById('ull');
    const lllInput = getById('lll');
    const urlimbInput = getById('urlimb');
    const lrlimbInput = getById('lrlimb');
    const torsoInput = getById('torso');
    const headInput = getById('head');
    const startFrameInput = getById('startFrame');
    const endFrameInput = getById('endFrame');
    const btnAddLabel = getById('btnAddLabel');
    const rangesTbody = getById('rangesTbody');

    const timeline = getById('timeline');
    const ticks = getById('ticks');
    const playhead = getById('playhead');
    const frameOut = getById('frameOut');
    const timeOut = getById('timeOut');
    const zoom = getById('zoom');
    const DEFAULT_FRAMES_PER_LINE = 100;
    const MIN_FRAMES_PER_LINE = 1;
    let userAdjustedZoom = false;

    let labelLanes = [];
    function initLabelLanes(){
      labelLanes = Array.from(document.querySelectorAll('.label-lane'));
    }

    // Store ranges per lane: {uid, labelId, lane, name, start, end, el}
    const labelRanges = [[],[],[],[]];
    let nextRangeUid = 1;
    let nextLabel0Id = 1;

    // Layout constants
    const MIN_BAR_PX = 16; // minimum visible width for a range bar
    const BAR_HEIGHT = 27; // must match CSS height
    const BAR_VGAP = 4;    // vertical gap between stacked bars

    const DEFAULT_FPS = 30;
    const MIN_FPS = 1;
    const MAX_FPS = 240;

    let totalFrames = 0;
    let rafId = null;
    let selectedFile = null;

    // ---------- Helpers ----------
    const isFiniteNumber = (n) => Number.isFinite(n);
    function getFramesPerLine() {
      const raw = Number(zoom.value);
      const fallback = Math.max(MIN_FRAMES_PER_LINE, DEFAULT_FRAMES_PER_LINE);
      return (isFiniteNumber(raw) && raw > 0) ? Math.max(MIN_FRAMES_PER_LINE, raw) : fallback;
    }
    function getPxPerFrame() {
      const framesPerLine = getFramesPerLine();
      const viewportWidth = Math.max(timeline?.clientWidth || 0, 1);
      return viewportWidth / framesPerLine;
    }
    function getTickSteps(framesPerLine) {
      const targetMajorTicks = 10;
      if (!isFiniteNumber(framesPerLine) || framesPerLine <= 0) {
        return { minor: 1, major: 10 };
      }
      const roughMajor = framesPerLine / targetMajorTicks;
      const magnitude = Math.pow(10, Math.floor(Math.log10(Math.max(roughMajor, 1))));
      const baseCandidates = [1, 2, 5, 10];
      let major = magnitude;
      for (const c of baseCandidates) {
        const step = c * magnitude;
        major = step;
        if (roughMajor <= step) break;
      }
      const minor = Math.max(1, Math.round(major / 5));
      return { minor, major: Math.max(1, Math.round(major)) };
    }
    function findLabel0RangeFor(start, end) {
      return labelRanges[0].find(r => start >= r.start && end <= r.end);
    }
    function getValidFPS() {
      const n = Number(fpsInput.value);
      if (!isFiniteNumber(n) || n < MIN_FPS || n > MAX_FPS) return DEFAULT_FPS;
      return n;
    }
    function sanitizeFPSInput() {
      const n = Number(fpsInput.value);
      if (!isFiniteNumber(n) || n < MIN_FPS) fpsInput.value = String(DEFAULT_FPS);
      if (n > MAX_FPS) fpsInput.value = String(MAX_FPS);
    }
    function canSeek() {
      return isFiniteNumber(video.duration) && video.duration > 0;
    }
    function safeSetCurrentTime(t) {
      // Only set if video has a valid duration and time is finite
      if (!canSeek()) return;
      if (!isFiniteNumber(t)) return;
      const clamped = Math.min(video.duration, Math.max(0, t));
      if (isFiniteNumber(clamped)) video.currentTime = clamped;
    }

    function timeToFrame(time) {
      const fps = getValidFPS();
      return Math.floor((time * fps) + 1e-6);
    }
    function frameToTime(frame) {
      const fps = getValidFPS();
      return frame / fps;
    }
    function fmtTime(s) { return (s || 0).toFixed(3) + 's'; }

    function rebuildTimeline() {
      if (!canSeek()) return;
      sanitizeFPSInput();
      const fps = getValidFPS();
      totalFrames = Math.max(0, Math.floor(video.duration * fps));
      gotoInput.max = String(totalFrames);

      if (zoom) {
        const total = Math.max(1, totalFrames);
        const maxFrames = Math.max(total, 5000);
        const minFrames = MIN_FRAMES_PER_LINE;
        zoom.max = String(maxFrames);
        zoom.min = String(minFrames);
        const current = Math.max(minFrames, Math.min(maxFrames, Number(zoom.value) || minFrames));
        if (Number(zoom.value) !== current) zoom.value = String(current);
        if (!userAdjustedZoom) {
          zoom.value = String(Math.max(minFrames, total));
        }
        zoom.title = `${Math.round(getFramesPerLine())} frames visible across the viewport`;
      }

      const pxPerFrame = getPxPerFrame();
      const width = Math.max(totalFrames * pxPerFrame, timeline.clientWidth + 1);
      ticks.style.width = width + 'px';

      // draw ticks
      ticks.innerHTML = '';
      const framesPerLine = getFramesPerLine();
      const { minor, major } = getTickSteps(framesPerLine);
      for (let f = 0; f <= totalFrames; f += minor) {
        const x = f * pxPerFrame;
        const tick = document.createElement('div');
        const isMajor = f % major === 0;
        tick.className = 'tick' + (isMajor ? ' major' : '');
        tick.style.left = x + 'px';
        tick.style.height = isMajor ? '100%' : '70%';
        ticks.appendChild(tick);
        if (isMajor) {
          const label = document.createElement('div');
          label.className = 'tick-label';
          label.textContent = f;
          label.style.left = x + 'px';
          ticks.appendChild(label);
        }
      }
      if (totalFrames % major !== 0) {
        const x = totalFrames * pxPerFrame;
        const tick = document.createElement('div');
        tick.className = 'tick major';
        tick.style.left = x + 'px';
        tick.style.height = '100%';
        ticks.appendChild(tick);
        const label = document.createElement('div');
        label.className = 'tick-label';
        label.textContent = totalFrames;
        label.style.left = x + 'px';
        ticks.appendChild(label);
      }

      // Ensure lanes are present
      initLabelLanes();

      // Resize label tracks to match timeline width
      labelLanes.forEach((lane)=>{
        const track = lane.querySelector('.label-track');
        if (track) track.style.width = width + 'px';
      });

      // Reposition all range bars with minimum width
      labelRanges.forEach((laneArr)=>{
        laneArr.forEach(r => {
          const left = r.start * pxPerFrame;
          const w = Math.max(MIN_BAR_PX, (r.end - r.start) * pxPerFrame);
          if (r.el) { r.el.style.left = left + 'px'; r.el.style.width = w + 'px'; }
        });
      });

      // Re-layout to avoid overlaps and adjust lane heights
      layoutAllLanes();

      updatePlayhead();
    }

    function updatePlayhead() {
      const pxPerFrame = getPxPerFrame();
      const curTime = canSeek() ? video.currentTime : 0;
      const curFrame = timeToFrame(curTime);
      playhead.style.left = (curFrame * pxPerFrame) + 'px';
      frameOut.textContent = curFrame + ' / ' + totalFrames;
      timeOut.textContent = fmtTime(curTime);

      // Sync label lane playheads
      initLabelLanes();
      labelLanes.forEach((lane)=>{
        const lp = lane.querySelector('.label-playhead');
        if (lp) lp.style.left = (curFrame * pxPerFrame) + 'px';
      });
    }

    function tick() { updatePlayhead(); rafId = requestAnimationFrame(tick); }

    // Interactions
    btnPlay.addEventListener('click', () => { if (video.paused) video.play(); else video.pause(); });
    video.addEventListener('play', () => { btnPlay.textContent = '⏸ Pause'; if (!rafId) rafId = requestAnimationFrame(tick); });
    video.addEventListener('pause', () => { btnPlay.textContent = '▶ Play'; cancelAnimationFrame(rafId); rafId = null; updatePlayhead(); });

    fpsInput.addEventListener('change', () => { sanitizeFPSInput(); rebuildTimeline(); });
    zoom.addEventListener('input', () => { userAdjustedZoom = true; rebuildTimeline(); });
    window.addEventListener('resize', rebuildTimeline);

    btnPrev.addEventListener('click', () => stepFrames(-1));
    btnNext.addEventListener('click', () => stepFrames(1));
    btnGo.addEventListener('click', () => goToFrame(Number(gotoInput.value)));

    function stepFrames(delta) {
      if (!canSeek()) return;
      const t = video.currentTime + frameToTime(delta);
      safeSetCurrentTime(t);
      updatePlayhead();
    }
    function goToFrame(f) {
      if (!canSeek()) return;
      const n = Number(f);
      if (!isFiniteNumber(n)) return; // ignore invalid
      const clampedFrame = Math.min(totalFrames, Math.max(0, Math.floor(n)));
      const t = frameToTime(clampedFrame);
      safeSetCurrentTime(t);
      updatePlayhead();
    }

    // Seek by clicking timeline
    timeline.addEventListener('click', (e) => {
      if (!canSeek()) return;
      const rect = timeline.getBoundingClientRect();
      const x = e.clientX - rect.left + timeline.scrollLeft;
      const pxPerFrame = getPxPerFrame();
      const frame = Math.round(x / pxPerFrame);
      goToFrame(frame);
    });

    // Keyboard shortcuts to match help text
    document.addEventListener('keydown', (e) => {
      if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return; // don't hijack typing
      if (e.code === 'Space') { e.preventDefault(); btnPlay.click(); }
      else if (e.key === 'ArrowLeft') { e.preventDefault(); stepFrames(-1); }
      else if (e.key === 'ArrowRight') { e.preventDefault(); stepFrames(1); }
      else if (e.key === 'Home') { e.preventDefault(); goToFrame(0); }
      else if (e.key === 'End') { e.preventDefault(); goToFrame(totalFrames); }
    });

    // Scroll sync (two-way)
    let isSyncing = false;
    function syncScrollFrom(source){
      if (isSyncing) return; isSyncing = true;
      const scrollLeft = source.scrollLeft;
      initLabelLanes();
      if (source === timeline) {
        labelLanes.forEach(l => { l.scrollLeft = scrollLeft; });
      } else {
        timeline.scrollLeft = scrollLeft;
        labelLanes.forEach(l => { if (l !== source) l.scrollLeft = scrollLeft; });
      }
      isSyncing = false;
    }
    timeline.addEventListener('scroll', () => syncScrollFrom(timeline));
    initLabelLanes();
    labelLanes.forEach(lane => lane.addEventListener('scroll', () => syncScrollFrom(lane)));

    // ---------- Range helpers ----------
    function renderRangeBar(laneIndex, range){
      initLabelLanes();
      const lane = labelLanes[laneIndex];
      if (!lane) { console.warn('Lane not available for index', laneIndex); return null; }
      const pxPerFrame = getPxPerFrame();
      const bar = document.createElement('div');
      bar.className = 'range-bar';
      bar.dataset.uid = range.uid;
      bar.title = `${range.name} [${range.start} → ${range.end})`;
      const widthPx = Math.max(MIN_BAR_PX,(range.end - range.start) * pxPerFrame);
      bar.style.left = (range.start * pxPerFrame) + 'px';
      bar.style.width = widthPx + 'px';
      bar.textContent = range.name;

      const del = document.createElement('button');
      del.className = 'btn-mini';
      del.textContent = '×';
      del.style.position = 'absolute';
      del.style.right = '4px';
      del.style.top = '4px';
      del.addEventListener('click', (e)=>{ e.stopPropagation(); removeRange(range.uid); });
      bar.appendChild(del);

      lane.appendChild(bar);
      range.el = bar;
      return bar;
    }

    // Compute vertical stacking to avoid overlaps in each lane
    function layoutLaneBars(laneIndex){
      initLabelLanes();
      const lane = labelLanes[laneIndex];
      if (!lane) return;
      const pxPerFrame = getPxPerFrame();
      const items = [...labelRanges[laneIndex]];
      items.sort((a,b)=> (a.start-b.start) || (a.end-b.end));
      const rowsLastEnd = [];
      let maxRow = 0;
      items.forEach(r=>{
        let row = 0;
        while (row < rowsLastEnd.length && r.start < rowsLastEnd[row]) row++;
        rowsLastEnd[row] = Math.max(rowsLastEnd[row]||0, r.end);
        if (r.el){
          r.el.style.top = (4 + row * (BAR_HEIGHT + BAR_VGAP)) + 'px';
          const widthPx = Math.max(MIN_BAR_PX,(r.end - r.start) * pxPerFrame);
          r.el.style.left = (r.start * pxPerFrame) + 'px';
          r.el.style.width = widthPx + 'px';
        }
        if (row > maxRow) maxRow = row;
      });
      const needed = 4 + (maxRow+1)*(BAR_HEIGHT+BAR_VGAP) + 4;
      lane.style.height = Math.max(35, needed) + 'px';
    }

    function layoutAllLanes(){
      initLabelLanes();
      for (let i=0;i<labelLanes.length;i++) layoutLaneBars(i);
    }

    function addRange(laneIndex, name, start, end){
      if (!Number.isFinite(start) || !Number.isFinite(end)) { alert('Start/End must be numbers'); return; }
      start = Math.max(0, Math.floor(start));
      end = Math.max(0, Math.floor(end));
      if (end <= start) { alert('End must be > Start (exclusive)'); return; }
      if (canSeek() && totalFrames>0 && start > totalFrames) { alert('Start is beyond video length'); return; }

      let labelId;
      if (laneIndex === 0) {
        labelId = nextLabel0Id++;
      } else if (laneIndex === 1) {
        const parent = findLabel0RangeFor(start, end);
        if (!parent) {
          alert('Lane 1 labels must fall within an existing label 0 range.');
          return;
        }
        labelId = parent.labelId;
      } else {
        labelId = nextRangeUid;
      }

      const r = { uid: nextRangeUid++, labelId, lane: laneIndex, name: name || `Range ${Date.now()}`, start, end, el: null };
      labelRanges[laneIndex].push(r);
      renderRangeBar(laneIndex, r);
      refreshRangesTable();
      layoutLaneBars(laneIndex);
    }

    function clearLaneOneByLabel(labelId) {
      const laneOne = labelRanges[1];
      let removedAny = false;
      for (let i = laneOne.length - 1; i >= 0; i--){
        if (laneOne[i].labelId === labelId){
          const [r] = laneOne.splice(i,1);
          if (r.el && r.el.parentNode) r.el.parentNode.removeChild(r.el);
          removedAny = true;
        }
      }
      if (removedAny) layoutLaneBars(1);
    }

    function removeRange(uid){
      for (let laneIndex=0; laneIndex<labelRanges.length; laneIndex++){
        const arr = labelRanges[laneIndex];
        const i = arr.findIndex(r => r.uid === uid);
        if (i >= 0){
          const [r] = arr.splice(i,1);
          if (r.el && r.el.parentNode) r.el.parentNode.removeChild(r.el);
          if (r.lane === 0) clearLaneOneByLabel(r.labelId);
          refreshRangesTable();
          layoutLaneBars(laneIndex);
          return;
        }
      }
    }

    function refreshRangesTable(){
      rangesTbody.innerHTML='';
      labelRanges.forEach((arr, laneIndex)=>{
        arr.forEach(r=>{
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${r.labelId}</td><td>${laneIndex}</td><td>${r.name}</td><td>${r.start}</td><td>${r.end}</td>`;
          const tdAct = document.createElement('td');
          const btnDel = document.createElement('button'); btnDel.className='btn-mini'; btnDel.textContent='Delete';
          btnDel.addEventListener('click', ()=> removeRange(r.uid));
          tdAct.appendChild(btnDel);
          tr.appendChild(tdAct);
          rangesTbody.appendChild(tr);
        });
      });
    }

    // Add range from form
    btnAddLabel.addEventListener('click', ()=>{
      const laneIndex = Number(laneSelect.value)||0;
      let name;
      if (laneIndex === 1) {
        const u = (upperTextInput.value||'').trim();
        const l = (lowerTextInput.value||'').trim();
        if (!u && !l) { alert('Please fill at least one of Upper body text or Lower body text.'); return; }
        name = [u,l].filter(Boolean).join(' • ');
      } else if (laneIndex === 2) {
        const parts = [
          (ullInput?.value||'').trim(),
          (lllInput?.value||'').trim(),
          (urlimbInput?.value||'').trim(),
          (lrlimbInput?.value||'').trim(),
          (torsoInput?.value||'').trim(),
          (headInput?.value||'').trim()
        ].filter(Boolean);
        if (parts.length === 0) { alert('Please fill at least one of the six fields for label 2.'); return; }
        name = parts.join(' • ');
      } else {
        if (laneIndex === 3) {
          // Center of mass lane: default to label text "Center of mass" when empty
          name = (labelNameInput.value||'').trim() || 'Center of mass';
        } else {
          name = (labelNameInput.value||'').trim() || `label ${laneIndex}`;
        }
      }
      const start = Number(startFrameInput.value);
      const end = Number(endFrameInput.value);
      addRange(laneIndex, name, start, end);
      // Clear inputs after adding a label so the next entry starts blank
      clearLabelTextInputs();
    });

    // Toggle input UI based on lane selection
    function clearLabelTextInputs(){
      if (labelNameInput) labelNameInput.value='';
      if (upperTextInput) upperTextInput.value='';
      if (lowerTextInput) lowerTextInput.value='';
      if (ullInput) ullInput.value='';
      if (lllInput) lllInput.value='';
      if (urlimbInput) urlimbInput.value='';
      if (lrlimbInput) lrlimbInput.value='';
      if (torsoInput) torsoInput.value='';
      if (headInput) headInput.value='';
    }
    function updateNameInputs(){
      const laneIndex = Number(laneSelect.value)||0;
      const isDual = laneIndex === 1;
      const isSix  = laneIndex === 2;
      dualNameWrap.style.display = isDual ? 'flex' : 'none';
      sixNameWrap.style.display  = isSix  ? 'flex' : 'none';
      singleNameWrap.style.display = (!isDual && !isSix) ? 'block' : 'none';
      // Clear any pre-filled values when the user switches lanes
      clearLabelTextInputs();
    }
    laneSelect.addEventListener('change', updateNameInputs);
    updateNameInputs();

    // Loading from file input
    file.addEventListener('change', () => {
      if (!file.files || !file.files[0]) return;
      selectedFile = file.files[0];
      const src = URL.createObjectURL(selectedFile);
      loadVideo(src);
      if (selectedFile.type.includes('quicktime')) meta.innerHTML = (meta.innerHTML || '') + '<br/><b>Tip:</b> MOV may not play in this browser unless H.264.';
    });

    // Loading from URL box
    btnLoad.addEventListener('click', () => {
      if (!url.value.trim()) return;
      loadVideo(url.value.trim());
    });

    function loadVideo(src) {
      userAdjustedZoom = false;
      if (zoom) zoom.value = String(DEFAULT_FRAMES_PER_LINE);
      video.src = src;
      video.load();
      video.play().catch(()=>{});
    }

    // When metadata is ready, build timeline
    video.addEventListener('loadedmetadata', () => {
      const d = canSeek() ? video.duration : 0;
      meta.innerHTML = `Duration: <b>${fmtTime(d)}</b><br/>Resolution: <b>${video.videoWidth}×${video.videoHeight}</b>`;
      userAdjustedZoom = false;
      rebuildTimeline();
    });

    // Keep playhead synced on timeupdate (fallback)
    video.addEventListener('timeupdate', updatePlayhead);

    // Drag & drop
    document.addEventListener('dragover', (e)=>{ e.preventDefault(); });
    document.addEventListener('drop', (e)=>{ e.preventDefault(); const f = e.dataTransfer.files?.[0]; if (f && f.type.startsWith('video/')) { selectedFile = f; loadVideo(URL.createObjectURL(f)); if (f.type.includes('quicktime')) meta.innerHTML = (meta.innerHTML || '') + '<br/><b>Tip:</b> MOV may not play in this browser unless H.264.'; } });

    // ---------------- Dev self-tests ----------------
    (function runSelfTests(){
      try {
        // === Existing tests (unchanged) ===
        fpsInput.value = 30;
        const t = 1.0; // seconds
        const f = timeToFrame(t); // expect 30
        console.assert(f === 30, 'Test1 failed: timeToFrame(1s) at 30fps should be 30, got', f);
        const t2 = frameToTime(f);
        console.assert(Math.abs(t2 - 1.0) < 1e-6, 'Test2 failed: frameToTime(30) at 30fps should be 1.0s, got', t2);

        ['video','btnPlay','btnPrev','btnNext','fps','gotoFrame','btnGo','timeline','ticks','playhead','zoom'].forEach(id=>{
          console.assert(document.getElementById(id), 'Test3 failed: missing element #' + id);
        });

        console.assert(document.querySelectorAll('.label-lane').length === 4, 'Test4 failed: expected 4 label lanes');

        // === Added tests ===
        // Test 5: $ conflict avoided (informational)
        console.assert(typeof window.$ === 'undefined' || typeof window.$ === 'function', 'Test5 info: window.$ exists, but our code does not depend on it');
        console.assert(typeof getById === 'function', 'Test6 failed: helper getById missing');

        // Test 7: frame/time roundtrip for non-30 fps
        fpsInput.value = 60; sanitizeFPSInput();
        const fA = 120; // frames
        const tA = frameToTime(fA); // 2.0s
        console.assert(Math.abs(tA - 2.0) < 1e-6, 'Test7 failed: frameToTime at 60fps');
        const fB = timeToFrame(2.0);
        console.assert(fB === 120, 'Test8 failed: timeToFrame at 60fps');
        fpsInput.value = 30; sanitizeFPSInput();

        // Test 9: addRange validation & creation
        const preCount = labelRanges[0].length;
        addRange(0, 'test', 10, 20);
        console.assert(labelRanges[0].length === preCount + 1, 'Test9 failed: addRange should push to lane');
        // Test 10: removeRange
        const newUid = labelRanges[0][labelRanges[0].length-1].uid;
        removeRange(newUid);
        console.assert(labelRanges[0].every(r => r.uid !== newUid), 'Test10 failed: removeRange should delete the range');

        // Provide a covering label 0 range for downstream tests
        addRange(0, 'cover', 0, 200);
        const coverL0 = labelRanges[0][labelRanges[0].length-1];

        // Test 11: keyboard shortcuts are disabled when typing
        const inputEl = getById('labelName');
        inputEl.focus();
        const beforeTime = video.currentTime;
        const keyEvt = new KeyboardEvent('keydown', {key:'ArrowRight', bubbles:true});
        document.dispatchEvent(keyEvt);
        console.assert(video.currentTime === beforeTime, 'Test11 failed: ArrowRight should be ignored when input focused');
        inputEl.blur();

        // Test 12: invalid FPS values should be sanitized and never yield NaN times
        fpsInput.value = 'abc'; sanitizeFPSInput();
        console.assert(getValidFPS() === 30, 'Test12 failed: non-numeric FPS should fallback to 30');
        fpsInput.value = '0'; sanitizeFPSInput();
        console.assert(getValidFPS() >= 1, 'Test12b failed: zero FPS should be corrected');
        fpsInput.value = '9999'; sanitizeFPSInput();
        console.assert(getValidFPS() <= 240, 'Test12c failed: huge FPS should be clamped');
        fpsInput.value = '30'; sanitizeFPSInput();

        // Test 13: goToFrame should ignore NaN/Infinity and not set non-finite currentTime
        const timeBefore = video.currentTime;
        goToFrame(NaN);
        goToFrame(Infinity);
        console.assert(isFinite(video.currentTime) && video.currentTime === timeBefore, 'Test13 failed: goToFrame with invalid should not change currentTime');

        // Test 14: very short range should still be min width
        const pxPerFrame = getPxPerFrame();
        addRange(0,'tiny',100,101);
        const tiny = labelRanges[0][labelRanges[0].length-1];
        console.assert(tiny.el && parseFloat(tiny.el.style.width) >= MIN_BAR_PX, 'Test14 failed: tiny range should have minimum pixel width');
        removeRange(tiny.uid);

        // Test 15: overlapping ranges should stack vertically
        const baseCount = labelRanges[1].length;
        addRange(1,'A',10,30);
        addRange(1,'B',20,40);
        const a = labelRanges[1][baseCount];
        const b = labelRanges[1][baseCount+1];
        console.assert(a.el && b.el && a.el.style.top !== b.el.style.top, 'Test15 failed: overlapping bars did not stack');
        console.assert(a.labelId === coverL0.labelId && b.labelId === coverL0.labelId, 'Test15b failed: lane1 ranges should inherit label0 id');
        removeRange(a.uid); removeRange(b.uid);

        // Test 16: lane 1 requires at least one of the two texts
        const preLane1 = labelRanges[1].length;
        laneSelect.value = '1'; updateNameInputs();
        upperTextInput.value=''; lowerTextInput.value='';
        const prevCount = labelRanges[1].length;
        btnAddLabel.click();
        console.assert(labelRanges[1].length === prevCount, 'Test16 failed: should not add when both upper/lower empty');

        // Test 17: lane 1 accepts only upper
        upperTextInput.value='UpperOnly'; lowerTextInput.value='';
        startFrameInput.value='0'; endFrameInput.value='5';
        btnAddLabel.click();
        console.assert(labelRanges[1].length === preLane1+1, 'Test17 failed: should add when upper provided');
        const last1 = labelRanges[1][labelRanges[1].length-1];
        console.assert(last1.name.includes('UpperOnly'), 'Test17b failed: composed name should include upper text');
        console.assert(last1.labelId === coverL0.labelId, 'Test17c failed: lane1 range should reuse label0 id');
        removeRange(last1.uid);

        // Test 18: lane 1 accepts both and composes name with separator
        upperTextInput.value='U'; lowerTextInput.value='L';
        startFrameInput.value='1'; endFrameInput.value='6';
        btnAddLabel.click();
        const last2 = labelRanges[1][labelRanges[1].length-1];
        console.assert(last2.name.includes('U • L'), 'Test18 failed: name should be "U • L" when both provided');
        removeRange(last2.uid);

        // Test 18b: lane 1 cannot add outside label 0 coverage
        const beforeInvalidLane1 = labelRanges[1].length;
        upperTextInput.value='Outside'; lowerTextInput.value='';
        startFrameInput.value='250'; endFrameInput.value='255';
        btnAddLabel.click();
        console.assert(labelRanges[1].length === beforeInvalidLane1, 'Test18b failed: lane 1 range should be rejected when outside label 0 span');

        // Test 19: lane 2 requires at least one value
        laneSelect.value = '2'; updateNameInputs();
        if (ullInput && lllInput && urlimbInput && lrlimbInput && torsoInput && headInput) {
          ullInput.value = lllInput.value = urlimbInput.value = lrlimbInput.value = torsoInput.value = headInput.value = '';
          const beforeL2 = labelRanges[2].length;
          btnAddLabel.click();
          console.assert(labelRanges[2].length === beforeL2, 'Test19 failed: lane 2 should not add when all six empty');

          // Test 20: lane 2 accepts one field
          ullInput.value = 'UL';
          startFrameInput.value='2'; endFrameInput.value='7';
          btnAddLabel.click();
          console.assert(labelRanges[2].length === beforeL2+1, 'Test20 failed: lane 2 should add when one field provided');
          const lastL2a = labelRanges[2][labelRanges[2].length-1];
          console.assert(lastL2a.name.includes('UL'), 'Test20b failed: lane 2 composed name should contain provided part');
          removeRange(lastL2a.uid);

          // Test 21: lane 2 composes multiple fields with separator
          ullInput.value='UL'; lllInput.value='LL'; urlimbInput.value='UR'; lrlimbInput.value='LR'; torsoInput.value='T'; headInput.value='H';
          startFrameInput.value='3'; endFrameInput.value='8';
          btnAddLabel.click();
          const lastL2b = labelRanges[2][labelRanges[2].length-1];
          console.assert(lastL2b.name.includes('UL • LL • UR • LR • T • H'), 'Test21 failed: lane 2 name should join all non-empty fields');
          removeRange(lastL2b.uid);
        }

        // Test 22: lane 3 shows Center of mass placeholder
        laneSelect.value = '3'; updateNameInputs();
        console.assert(labelNameInput.placeholder === '', 'Test22 failed: lane 3 should have no placeholder');
        // Test 23: lane 3 default label when empty
        const beforeL3 = labelRanges[3].length;
        labelNameInput.value = '';
        startFrameInput.value='4'; endFrameInput.value='9';
        btnAddLabel.click();
        const lastL3 = labelRanges[3][labelRanges[3].length-1];
        console.assert(lastL3 && lastL3.name === 'Center of mass', 'Test23 failed: lane 3 default name should be "Center of mass"');
        removeRange(lastL3.uid);
        labelNameInput.value = ''; // cleanup test residue so UI doesn't keep COM text
        // Test 24: lane 3 uses custom input when provided
        labelNameInput.value = 'COM Custom';
        btnAddLabel.click();
        const lastL3c = labelRanges[3][labelRanges[3].length-1];
        console.assert(lastL3c && lastL3c.name === 'COM Custom', 'Test24 failed: lane 3 should use custom input value');
        removeRange(lastL3c.uid);
        labelNameInput.value = ''; // cleanup test residue

        // Test 25: lane 1 inputs have no placeholders
        laneSelect.value = '1'; updateNameInputs();
        console.assert((upperTextInput.placeholder||'') === '' && (lowerTextInput.placeholder||'') === '', 'Test25 failed: lane 1 inputs should have no placeholder');
        // Test 26: lane 2 inputs have no placeholders
        laneSelect.value = '2'; updateNameInputs();
        const l2NoPh = [ullInput, lllInput, urlimbInput, lrlimbInput, torsoInput, headInput].every(el => (el.placeholder||'') === '');
        console.assert(l2NoPh, 'Test26 failed: lane 2 inputs should have no placeholder');

        // Test 27: switching lanes clears text inputs
        laneSelect.value='1'; updateNameInputs();
        upperTextInput.value='foo'; lowerTextInput.value='bar';
        laneSelect.value='2'; updateNameInputs();
        const laneSwitchCleared = [upperTextInput.value, lowerTextInput.value].every(v=>v==='');
        console.assert(laneSwitchCleared, 'Test27 failed: lane switch should clear previous lane text inputs');

        // Test 28: after Add, inputs are cleared
        laneSelect.value='1'; updateNameInputs();
        upperTextInput.value='U'; startFrameInput.value='0'; endFrameInput.value='2';
        btnAddLabel.click();
        const clearedAfterAdd = (upperTextInput.value==='') && (lowerTextInput.value==='');
        console.assert(clearedAfterAdd, 'Test28 failed: inputs should be cleared after adding a range');
        // Clean up the test-created range so the table starts empty
        if (labelRanges[1].length) {
          const justAdded = labelRanges[1][labelRanges[1].length-1];
          removeRange(justAdded.uid);
        }

        // Clean up the covering lane 0 range for future manual testing
        removeRange(coverL0.uid);

        console.log('%cSelf-tests passed', 'color:#3ad29f');
      } catch (e) {
        console.warn('Self-tests encountered an issue:', e);
      }
    })();
  -->
</body>
</html>
